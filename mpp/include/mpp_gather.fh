!***********************************************************************
!*                             Apache License 2.0
!*
!* This file is part of the GFDL Flexible Modeling System (FMS).
!*
!* Licensed under the Apache License, Version 2.0 (the "License");
!* you may not use this file except in compliance with the License.
!* You may obtain a copy of the License at
!*
!*     http://www.apache.org/licenses/LICENSE-2.0
!*
!* FMS is distributed in the hope that it will be useful, but WITHOUT
!* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied;
!* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
!* PARTICULAR PURPOSE. See the License for the specific language
!* governing permissions and limitations under the License.
!***********************************************************************
!> @file

!> @addtogroup mpp_mod
!> @{
subroutine MPP_GATHER_1D_(sbuf, rbuf, pelist)
! JWD: Did not create mpp_gather_2d because have no requirement for it
! JWD: See mpp_gather_2dv below
   MPP_TYPE_, dimension(:),    intent(in) :: sbuf
   MPP_TYPE_, dimension(:), intent(inout) :: rbuf
   integer,   dimension(:),    intent(in), optional :: pelist(:)

   integer :: cnt, l, nproc, op_root, ierr
   integer, allocatable :: pelist2(:)

   if( .NOT.module_is_initialized ) call mpp_error( FATAL, 'MPP_GATHER_1D_: You must first call mpp_init.' )

!  If pelist is provided, the first position must be the operation root, w.r.t. new comm, op_root = 0
   if(PRESENT(pelist))then
      if(.not.ANY(mpp_pe().eq.pelist(:))) return
      nproc = size(pelist)
      allocate(pelist2(nproc))
      pelist2 = pelist
   else
      nproc = mpp_npes()
      allocate(pelist2(nproc))
      pelist2 = (/ (l, l=root_pe, nproc-1+root_pe) /)
   endif
   op_root = pelist2(1)

   cnt = size(sbuf(:))
   if((mpp_pe().eq.op_root).AND.(size(rbuf(:)) < cnt*nproc)) call mpp_error(FATAL, &
          "MPP_GATHER_1D_: size(rbuf) must be at least npes*size(sbuf) ")

   call mpp_gather( sbuf, rbuf, size(sbuf), op_root, pelist2, ierr )

   call mpp_sync_self()
   deallocate(pelist2)
end subroutine MPP_GATHER_1D_

subroutine MPP_GATHER_1DV_(sbuf, ssize, rbuf, rsize, pelist)
   MPP_TYPE_, dimension(:),    intent(in) :: sbuf
   MPP_TYPE_, dimension(:), intent(inout) :: rbuf
   integer,                    intent(in) :: ssize
   integer,   dimension(:),    intent(in) :: rsize
   integer,   dimension(:),    intent(in), optional :: pelist(:)

   integer :: l, nproc, op_root, ierr
   integer, dimension(:), allocatable :: displs
   integer, dimension(:), allocatable :: pelist2

!  If pelist is provided, the first position must be
!  the operation root
   if(PRESENT(pelist))then
      nproc = size(pelist)
      allocate(pelist2(nproc))
      pelist2 = pelist
   else
      nproc = mpp_npes()
      allocate(pelist2(nproc))
      pelist2 = (/ (l, l=root_pe, nproc-1+root_pe) /)
   endif
   op_root = pelist2(1)

   if(pe .eq. op_root) then
      allocate(displs(nproc))

      displs(1) = 0
      do l = 2, nproc
         displs(l) = displs(l-1) + rsize(l-1)
      enddo
   else
      allocate(displs(1))
   endif

   call mpp_gather( sbuf, ssize, rbuf, rsize, displs, op_root, pelist2, ierr )

   call mpp_sync_self()
   deallocate(pelist2)
   deallocate(displs)
end subroutine MPP_GATHER_1DV_


subroutine MPP_GATHER_PELIST_2D_(is, ie, js, je, pelist, array_seg, gather_data, is_root_pe, &
                                 ishift, jshift)
   integer,                                       intent(in)    :: is, ie, js, je
   integer,   dimension(:),                       intent(in)    :: pelist
   MPP_TYPE_, dimension(is:ie,js:je),     target, intent(in)    :: array_seg
   MPP_TYPE_, dimension(:,:), contiguous, target, intent(inout) :: gather_data
   logical,                                       intent(in)    :: is_root_pe
   integer,   optional,                           intent(in)    :: ishift, jshift

   MPP_TYPE_, pointer ::  arr3D(:,:,:)
   MPP_TYPE_, pointer :: data3D(:,:,:)

   arr3D(1:size(array_seg,1),1:size(array_seg,2),1:1) => array_seg
   if (is_root_pe) then
     data3D(1:size(gather_data,1),1:size(gather_data,2),1:1) => gather_data
   else
     data3D => null()
   endif

   call mpp_gather(is, ie, js, je, 1, pelist, arr3D, data3D, is_root_pe, &
                   ishift, jshift)
   return

end subroutine MPP_GATHER_PELIST_2D_


subroutine MPP_GATHER_PELIST_3D_(is, ie, js, je, nk, pelist, array_seg, gather_data, is_root_pe, &
                                 ishift, jshift)
   integer,                                intent(in)    :: is, ie, js, je, nk
   integer,   dimension(:),                intent(in)    :: pelist
   MPP_TYPE_, dimension(is:ie,js:je,1:nk), intent(in)    :: array_seg
   MPP_TYPE_, dimension(:,:,:),            intent(inout) :: gather_data
   logical,                                intent(in)    :: is_root_pe
   integer,   optional,                    intent(in)    :: ishift, jshift

   integer :: i, j, k
   integer :: root_pe, root_pe_test
   integer :: i1, i2, j1, j2, ioff, joff
   integer :: base_idx, send_count, msg_start
   integer :: blocksize_i, blocksize_j, blocksize
   integer, dimension(:), allocatable :: gind, counts
   MPP_TYPE_, dimension(:), allocatable :: rbuf

   if (.not.ANY(mpp_pe().eq.pelist(:))) return

   if (is_root_pe) then
     root_pe = mpp_pe()
     root_pe_test = 999
     if (.not.ANY(pelist(:).eq.root_pe)) call mpp_error(FATAL, &
                "fms_io(mpp_gather_pelist): root_pe not a member of pelist")
   else
     root_pe = 0
     root_pe_test = -999
   endif
! need this check in case MPI-rank 0 is a member of the pelist
   call mpp_max(root_pe_test, pelist)
   if (root_pe_test.lt.0) call mpp_error(FATAL, &
                "fms_io(mpp_gather_pelist): root_pe not specified or not a member of the pelist")
! need to make sure only one root_pe has been specified
   call mpp_sum(root_pe, pelist)
   if ((is_root_pe) .and. (mpp_pe().ne.root_pe)) call mpp_error(FATAL, &
                "fms_io(mpp_gather_pelist): too many root_pes specified")


   ioff=0
   joff=0
   if (present(ishift)) ioff=ishift
   if (present(jshift)) joff=jshift

   ! gather indices into global index on root_pe
   if (is_root_pe) allocate(gind(4*size(pelist)))
   call mpp_gather((/is, ie, js, je/), gind, pelist)

   ! Compute and allocate counts and 1d recv buffer (rbuf)
   if (is_root_pe) then
      allocate(counts(size(pelist)))

      do k = 1, size(pelist)
         base_idx = 4*(k-1)
         i1 = gind( base_idx + 1 ) ;; i2 = gind( base_idx + 2 )
         j1 = gind( base_idx + 3 ) ;; j2 = gind( base_idx + 4 )
         counts(k) = (i2 - i1 + 1) * (j2 - j1 + 1) * nk
      enddo

      allocate(rbuf(sum(counts)))
   endif

   send_count = (ie-is+1)*(je-js+1)*nk

   ! gather data into 1d recv buffer
   call mpp_gather(reshape(array_seg(is:ie,js:je,1:nk),[send_count]), send_count, rbuf, counts, pelist)

   ! Unpack recv buffer into return array (gather_data)
   if (is_root_pe) then
      msg_start = 1
      do k = 1, size(pelist)
         base_idx = 4*(k-1)
         i1 = gind( base_idx + 1 ) + ioff ;; i2 = gind( base_idx + 2 ) + ioff
         j1 = gind( base_idx + 3 ) + joff ;; j2 = gind( base_idx + 4 ) + joff

         blocksize_i = i2 - i1 + 1
         blocksize_j = j2 - j1 + 1
         blocksize   = blocksize_i * blocksize_j * nk

         gather_data(i1:i2, j1:j2, 1:nk) = reshape(rbuf(msg_start:msg_start+blocksize-1), & 
                                                         [blocksize_i, blocksize_j, nk])

         msg_start = msg_start + blocksize
      enddo

      deallocate(gind, rbuf, counts)
   endif

   call mpp_sync_self()

end subroutine MPP_GATHER_PELIST_3D_
!> @}
