!***********************************************************************
!*                             Apache License 2.0
!*
!* This file is part of the GFDL Flexible Modeling System (FMS).
!*
!* Licensed under the Apache License, Version 2.0 (the "License");
!* you may not use this file except in compliance with the License.
!* You may obtain a copy of the License at
!*
!*     http://www.apache.org/licenses/LICENSE-2.0
!*
!* FMS is distributed in the hope that it will be useful, but WITHOUT
!* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied;
!* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
!* PARTICULAR PURPOSE. See the License for the specific language
!* governing permissions and limitations under the License.
!***********************************************************************

      !> Pack an array into a vector
      !> @ingroup mpp_domains_mod
      subroutine ARR2VEC_ (arr, vec, ix, iy, is, ie, js, je)
        MPP_TYPE_, intent(in) :: arr(..) !< The array to be packed
        MPP_TYPE_, intent(out) :: vec(:) !< The vector to copy the data into
        integer, intent(in) :: ix, iy !< Indices of the domain-decomposed dimensions
        integer, intent(in) :: is, ie, js, je !< Starting and ending indices of the x and y dimensions
        integer, allocatable, dimension(:) :: lb, ub
        integer :: n, m
        integer :: i1, i2, i3, i4, i5

        n = rank(arr)
        allocate (lb(n), ub(n))

        lb = 1
        ub = shape(arr)

        lb(ix) = is
        lb(iy) = js

        ub(ix) = ie
        ub(iy) = je

        m = 0
        select rank(arr)
          rank (2)
            do i2=lb(2),ub(2)
              do i1=lb(1),ub(1)
                m = m + 1
                vec(m) = arr(i1, i2)
              enddo
            enddo
          rank (3)
            do i3=lb(3),ub(3)
              do i2=lb(2),ub(2)
                do i1=lb(1),ub(1)
                  m = m + 1
                  vec(m) = arr(i1, i2, i3)
                enddo
              enddo
            enddo
          rank (4)
            do i4=lb(4),ub(4)
              do i3=lb(3),ub(3)
                do i2=lb(2),ub(2)
                  do i1=lb(1),ub(1)
                    m = m + 1
                    vec(m) = arr(i1, i2, i3, i4)
                  enddo
                enddo
              enddo
            enddo
          rank (5)
            do i5=lb(5),ub(5)
              do i4=lb(4),ub(4)
                do i3=lb(3),ub(3)
                  do i2=lb(2),ub(2)
                    do i1=lb(1),ub(1)
                      m = m + 1
                      vec(m) = arr(i1, i2, i3, i4, i5)
                    enddo
                  enddo
                enddo
              enddo
            enddo
        end select
      end subroutine ARR2VEC_

      !> Unpack a vector into an array
      !> @ingroup mpp_domains_mod
      subroutine VEC2ARR_ (vec, arr, ix, iy, is, ie, js, je)
        MPP_TYPE_, intent(in) :: vec(:) !< The vector to be unpacked
        MPP_TYPE_, intent(out) :: arr(..) !< The array to copy the data into
        integer, intent(in) :: ix, iy !< Indices of the domain-decomposed dimensions
        integer, intent(in) :: is, ie, js, je !< Starting and ending indices of the x and y dimensions
        integer, allocatable, dimension(:) :: lb, ub
        integer :: n, m
        integer :: i1, i2, i3, i4, i5

        n = rank(arr)
        allocate (lb(n), ub(n))

        lb = 1
        ub = shape(arr)

        lb(ix) = is
        lb(iy) = js

        ub(ix) = ie
        ub(iy) = je

        m = 0
        select rank(arr)
          rank (2)
            do i2=lb(2),ub(2)
              do i1=lb(1),ub(1)
                m = m + 1
                arr(i1, i2) = vec(m)
              enddo
            enddo
          rank (3)
            do i3=lb(3),ub(3)
              do i2=lb(2),ub(2)
                do i1=lb(1),ub(1)
                  m = m + 1
                  arr(i1, i2, i3) = vec(m)
                enddo
              enddo
            enddo
          rank (4)
            do i4=lb(4),ub(4)
              do i3=lb(3),ub(3)
                do i2=lb(2),ub(2)
                  do i1=lb(1),ub(1)
                    m = m + 1
                    arr(i1, i2, i3, i4) = vec(m)
                  enddo
                enddo
              enddo
            enddo
          rank (5)
            do i5=lb(5),ub(5)
              do i4=lb(4),ub(4)
                do i3=lb(3),ub(3)
                  do i2=lb(2),ub(2)
                    do i1=lb(1),ub(1)
                      m = m + 1
                      arr(i1, i2, i3, i4, i5) = vec(m)
                    enddo
                  enddo
                enddo
              enddo
            enddo
        end select
      end subroutine VEC2ARR_

      !> Initialize an assumed-rank array
      !> @ingroup mpp_domains_mod
      subroutine ARR_INIT_ (arr, val)
        MPP_TYPE_, dimension(..), intent(out) :: arr !< The array to be initialized
        MPP_TYPE_, intent(in) :: val !< The initialization value

        select rank (arr)
          rank(1)
            arr = val
          rank(2)
            arr = val
          rank(3)
            arr = val
          rank(4)
            arr = val
          rank(5)
            arr = val
        end select
      end subroutine ARR_INIT_
